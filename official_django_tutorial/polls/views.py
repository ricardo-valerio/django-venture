from django.shortcuts import render
# Create your views here.

# from django.http import HttpResponse
# from django.template import RequestContext, loader
# from django.http import Http404
from django.shortcuts import get_object_or_404
from .models import Question, Choice

from django.http import HttpResponseRedirect
from django.core.urlresolvers import reverse
from django.views import generic
from django.utils import timezone

"""
Each view is responsible for doing one of two things:
1- returning an HttpResponse object containing the content
   for the requested page,
2- or raising an exception such as Http404.

The rest is up to you.

Your view can read records from a database, or not.
It can use a template system such as Django’s
– or a third-party Python template system – or not.
It can generate a PDF file, output XML, create a ZIP file on the fly,
anything you want, using whatever Python libraries you want.

All Django wants is that HttpResponse. Or an exception.
"""


# to avoid design logic in this methods it's better to create
# a "templates" folder and django will auto lookup for equal names
#
# Your project’s TEMPLATES setting describes how Django will load and
# render templates. The default settings file configures a DjangoTemplates
# backend whose APP_DIRS option is set to True.
# By convention DjangoTemplates looks for a “templates” subdirectory in each
# of the INSTALLED_APPS. This is how Django knows to find the polls templates
# even though we didn’t modify the DIRS option, as we did in Tutorial 2.
#
# def index(request):
#     latest_question_list = Question.objects.order_by('-pub_date')[:5]
#     context = {'latest_question_list': latest_question_list}
#     return render(request, 'polls/index.html', context)


# latest_question_list = Question.objects.order_by('-pub_date')[:5]
# template = loader.get_template('polls/index.html')
# context = RequestContext(request, {
#     'latest_question_list': latest_question_list,
# })
# return HttpResponse(template.render(context))


# def detail(request, question_id):
#     question = get_object_or_404(Question, pk=question_id)
#     return render(request, 'polls/detail.html', {'question': question})
#     """
#     There’s also a get_list_or_404() function, which works just
#     as get_object_or_404() – except using filter() instead of get().
#     It raises Http404 if the list is empty.
#     """

# 2
# try:
#     question = Question.objects.get(pk=question_id)
# except Question.DoesNotExist:
#     raise Http404("Question does not exist")
# return render(request, 'polls/detail.html', {'question': question})

# 1
# return HttpResponse("You're looking at question %s." % question_id)


# def results(request, question_id):
#     question = get_object_or_404(Question, pk=question_id)
#     return render(request, 'polls/results.html', {'question': question})
#
# 1
# response = "You're looking at the results of question %s."
# return HttpResponse(response % question_id)


# By default, the DetailView generic view uses a template
# called <app name>/<model name>_detail.html. In our case,
# it would use the template "polls/question_detail.html".
# The template_name attribute is used to tell Django to use a specific
# template name instead of the autogenerated default template name.
#  We also specify the template_name for the results list view
# – this ensures that the results view and the detail view have a different
# appearance when rendered, even though they’re both a
# DetailView behind the scenes.
#
# Similarly, the ListView generic view uses a default template called
# <app name>/<model  name>_list.html;
# we use template_name to tell ListView to use our existing
#  "polls/index.html" template.
#
# n previous parts of the tutorial, the templates have been provided
#  with a context that contains the question and latest_question_list
# context variables. For DetailView the question variable is provided
# automatically – since we’re using a Django model (Question),
# Django is able to determine an appropriate name for the context variable.
# However, for ListView, the automatically generated context variable
# is question_list. To override this we provide the context_object_name
# attribute, specifying that we want to use latest_question_list instead.
# As an alternative approach, you could change your templates to match
# the new default context variables – but it’s a lot easier to just tell
# Django to use the variable you want.

class IndexView(generic.ListView):
    template_name = 'polls/index.html'
    context_object_name = 'latest_question_list'

    def get_queryset(self):
        """
        Return the last five published questions (not including those set to be
        published in the future).
        """
        return Question.objects.filter(pub_date__lte=timezone.now()).order_by(
            '-pub_date')[:5]


# The DetailView generic view expects the primary key value captured from the
# URL to be called "pk", so we’ve changed question_id to pk
# for the generic views.
class DetailView(generic.DetailView):
    model = Question
    template_name = 'polls/detail.html'

    def get_queryset(self):
        """
        Excludes any questions that aren't published yet.
        """
        return Question.objects.filter(pub_date__lte=timezone.now())


class ResultsView(generic.DetailView):
    model = Question
    template_name = 'polls/results.html'


def vote(request, question_id):
    p = get_object_or_404(Question, pk=question_id)
    try:
        selected_choice = p.choice_set.get(pk=request.POST['choice'])
    except (KeyError, Choice.DoesNotExist):
        # Redisplay the question voting form.
        return render(request, 'polls/detail.html', {
            'question': p,
            'error_message': "You didn't select a choice.",
        })
    else:
        selected_choice.votes += 1
        selected_choice.save()
        # Always return an HttpResponseRedirect after successfully dealing
        # with POST data. This prevents data from being posted twice if a
        # user hits the Back button.
        return HttpResponseRedirect(reverse('polls:results', args=(p.id,)))
